= VI: Projection for queries
:page-supergroup-java-scala: Language

include::ROOT:partial$include.adoc[]

Next, we will create an {akka-projection}/[Akka Projection {tab-icon}, window="tab"] from the events emitted by the `ShoppingCart` entity. The Projection will update counts in the database to track item popularity. Then, we can query the database to find how popular an item is. Since `ShoppingCart` entities can only be addressed by individual cart identifiers, we can find a particular cart, but we can't find all carts that contain a particular item.

ifdef::review[REVIEWERS: I don't follow the logic at the end of the last sentence in the prev para. Is it that each shopping cart only knows about it's own items?]


[caption=""]
image::example-projection-query.png[Example query]

This piece of the xref:overview.adoc[full example] focuses on the `ItemPopularityProjection` and a query representation in the database. On this page you will learn how to:

* implement a Projection
* distribute the Projection instances over the nodes in the Akka Cluster
* work with the Projection JDBC API

The xref:concepts:cqrs.adoc[CQRS] section explains why it is a good practice to build a Projection from entity events that can be queried. The {akka-blog}/news/2020/09/10/akka-projection-intro-video[Introduction to Akka Projections video {tab-icon}, window="tab"] is also a good starting point for learning about Akka Projections.

This example is using PostgreSQL for storing the Projection result and the Projection offset. An alternative is described in xref:how-to:cassandra-alternative.adoc[].

== Source downloads

If you prefer to simply view and run the example, download a zip file containing the completed code:

[.tabset]
Java::
+
****
* link:_attachments/3-shopping-cart-event-sourced-complete-java.zip[Source] that includes all previous tutorial steps and allows you to start with the steps on this page.
* link:_attachments/4-shopping-cart-projection-java.zip[Source] with the steps on this page completed.
****

Scala::
+
****
* link:_attachments/3-shopping-cart-event-sourced-complete-scala.zip[Source] that includes all previous tutorial steps and allows you to start with the steps on this page.
* link:_attachments/4-shopping-cart-projection-scala.zip[Source] with the steps on this page completed.
****

:sectnums:
== Process events in a Projection

To process events in a projection, we will: 

* encapsulate database access with `ItemPopularityRepository`, which can have a stubbed implementation for tests
* add Repository implementation for JDBC
* implement the event processing of the Projection in a `Handler`

[.group-java]
****
The Java variant uses Spring Data and Hibernate.
The template provides a few integration classes for that purpose, for instance: `HibernateJdbcSession`, `SpringConfig` and `SpringIntegration`.

How these classes work won't be covered by this tutorial. Consult their respective source code in the template for more information on how they provide the necessary glue code.
****

Follow these steps to process events in a Projection:


. Add the `ItemPopularityRepository`:
+
[.tabset]
Java::
+
.src/main/java/shopping/cart/ItemPopularityRepository.java:
[source,java,indent=0]
----
include::example$04-shopping-cart-service-java/src/main/java/shopping/cart/repository/ItemPopularityRepository.java[]
----

Scala::
+
.src/main/scala/shopping/cart/ItemPopularityRepository.scala:
[source,scala,indent=0]
----
include::example$04-shopping-cart-service-scala/src/main/scala/shopping/cart/ItemPopularityRepository.scala[tag=trait]
----

.  [.group-java]#Use Spring ApplicationContext to retrieve the implementation for the repository# [.group-scala]#Add the implementation for Postgres:#
+
[.tabset]
Java::
+
.src/main/java/shopping/cart/Main.java:
[source,java,indent=0]
----
include::example$04-shopping-cart-service-java/src/main/java/shopping/cart/Main.java[tag=repo-instance]
----
+
<1> Initialize a Spring application context using ActorSystem's configuration.
<2> Get a Spring generated implementation for the `ItemPopularityRepository`.

Scala::
+
.src/main/scala/shopping/cart/ItemPopularityRepository.scala:
[source,scala,indent=0]
----
include::example$04-shopping-cart-service-scala/src/main/scala/shopping/cart/ItemPopularityRepository.scala[tag=impl]
----


. Add a class `ItemPopularityProjectionHandler`:
+
[.tabset]
Java::
+
.src/main/java/shopping/cart/ItemPopularityProjectionHandler.java:
[source,java,indent=0]
----
include::example$04-shopping-cart-service-java/src/main/java/shopping/cart/ItemPopularityProjectionHandler.java[tags=handler]
----
+
<1> Extends `akka.projection.javadsl.Handler`.
<2> The `process` method to implement.
<3> Match events and increment or decrement the count via the `ItemPopularityRepository`, which encapsulates the database access.

Scala::
+
.src/main/scala/shopping/cart/ItemPopularityProjectionHandler.scala:
[source,scala,indent=0]
----
include::example$04-shopping-cart-service-scala/src/main/scala/shopping/cart/ItemPopularityProjectionHandler.scala[tags=handler]
----
+
<1> Extends `akka.projection.scaladsl.Handler`.
<2> The `process` method to implement.
<3> Match events and increment or decrement the count via the `ItemPopularityRepository`.

== Initialize the Projection

We want to connect the events from the `ShoppingCart` with the Projection. Several instances of the Projection may run on different nodes of the Akka Cluster. Each Projection instance will consume a slice of the events to distribute the load. All events from a specific entity (cart id) will always be processed by the same Projection instance so that it can build a stateful model from the events if needed.

=== Create tags
[#tagging]

To connect the events from the entities with the Projection we need to tag the events. We should use several tags, each with a slice number, to distribute the events over several Projection instances. The tag is selected based on the modulo of the entity id's hash code (stable identifier) and the total number of tags. Each entity instance will tag its events using one of those tags, and the entity instance will always use the same tag.


Create tags as follows:

. Edit  [.group-scala]#`ShoppingCart.scala`# [.group-java]#`ShoppingCart.java`# to include the following:
+
[.tabset]
Java::
+
.src/main/java/shopping/cart/ShoppingCart.java
[source,java,indent=0]
----
include::example$04-shopping-cart-service-java/src/main/java/shopping/cart/ShoppingCart.java[tag=tagging]
----

Scala::
+
.src/main/scala/shopping/cart/ShoppingCart.scala
[source,scala,indent=0]
----
include::example$04-shopping-cart-service-scala/src/main/scala/shopping/cart/ShoppingCart.scala[tags=importEntityContext;tagging]
----

+
One of the tags is selected based on the `cartId`, which is the `entityContext.entityId`. The tag is assigned to the `EventSourcedBehavior`.

. [.group-scala]#In the `ShoppingCart.apply` method, add the `projectionTag` parameter and pass it to `.withTagger`:# [.group-java]#In the `ShoppingCart` constructor, add the `projectionTag` parameter and use it to override the `tagsFor` method:#
+
[.tabset]
Java::
+
.src/main/java/shopping/cart/ShoppingCart.java
[source,java,indent=0]
----
include::example$04-shopping-cart-service-java/src/main/java/shopping/cart/ShoppingCart.java[tag=withTagger]
----
+
<1> Use `tagsFor` to assign the `projectionTag`.

Scala::
+
.src/main/scala/shopping/cart/ShoppingCart.scala
[source,scala,indent=0]
----
include::example$04-shopping-cart-service-scala/src/main/scala/shopping/cart/ShoppingCart.scala[tag=withTagger]
----
+
<1> Use `withTagger` to assign the `projectionTag`.


NOTE: In this example, we use five different tags. Tagging is not easy to change later without system downtime. Before going live in production you should consider how many tags to use, see {akka-projection}/running.html[Akka Projections reference documentation {tab-icon}, window="tab"] for more information.

=== Create Projection
[#projection]

To create the Projection:

. Place the initialization code of the Projection in an `ItemPopularityProjection` [.group-scala]#object# [.group-java]#class#:
+
[.tabset]
Java::
+
.src/main/java/shopping/cart/ItemPopularityProjection.java:
[source,java,indent=0]
----
include::example$04-shopping-cart-service-java/src/main/java/shopping/cart/ItemPopularityProjection.java[tag=projection]
----
+
<1> `ShardedDaemonProcess` will manage the Projection instances. It ensures the Projection instances are always running and distributes them over the nodes in the Akka Cluster.
<2> The `tag` is selected based on the Projection instance's index, corresponding to *carts-0* to *carts-3* as explained in the tagging in the `ShoppingCart`.
<3> The source of the Projection is `EventSourcedProvider.eventsByTag` with the selected tag.
<4> Using the JDBC event journal.
<5> Using JDBC for offset storage of the Projection using `exactly-once` strategy. Offset and projected model will be persisted transactionally.
<6> Define a `HibernateJdbcSession` factory. The JDBC connection are create by the projection and used to save the offset and the projected model.
<7> Define a Projection `Handler` factory for the handler we wrote in the beginning of this part.

Scala::
+
.src/main/scala/shopping/cart/ItemPopularityProjection.scala:
[source,scala,indent=0]
----
include::example$04-shopping-cart-service-scala/src/main/scala/shopping/cart/ItemPopularityProjection.scala[tag=projection]
----
+
<1> `ShardedDaemonProcess` will manage the Projection instances. It ensures the Projection instances are always running and distributes them over the nodes in the Akka Cluster.
<2> The `tag` is selected based on the Projection instance's index, corresponding to *carts-0* to *carts-3* as explained in the tagging in the `ShoppingCart`.
<3> The source of the Projection is `EventSourcedProvider.eventsByTag` with the selected tag.
<4> Using the Cassandra event journal.
<5> Using Cassandra for offset storage of the Projection.
<6> Creating the Projection `Handler` that we wrote in the beginning of this part.

. Call the `ItemPopularityProjection.init` from `Main`:
+
[.tabset]
Java::
+
.src/main/java/shopping/cart/Main.java
[source,java,indent=0]
----
include::example$04-shopping-cart-service-java/src/main/java/shopping/cart/Main.java[tag=ItemPopularityProjection]
----
+
<1> Initialize a Spring application context using ActorSystem's configuration.
<2> Get a Spring generated implementation for the `ItemPopularityRepository`.
<3> Get a Spring `JpaTransactionManager` to pass to the Projection init method.
<4> Initialize the Projection passing all necessary dependencies.

Scala::
+
.src/main/scala/shopping/cart/Main.scala
[source,scala,indent=0]
----
include::example$04-shopping-cart-service-scala/src/main/scala/shopping/cart/Main.scala[tag=ItemPopularityProjection]
----
+
<1> The `CassandraSession` is looked up from the `CassandraSessionRegistry`.
<2> Instantiate the repository for Cassandra.
<3> Call the initialization of the Projection.

== Query

To expose the item popularity to the outside of the service we can add an operation in the gRPC `ShoppingCartService`. Follow these steps:

. Add a new `GetItemPopularity` operation to the `ShoppingCartService.proto`:
+
.src/main/protobuf/ShoppingCartService.proto
[source,protobuf,indent=0]
----
include::example$04-shopping-cart-service-scala/src/main/protobuf/ShoppingCartService.proto[tag=GetItemPopularity]
----

. Generate code from the new Protobuf specification by compiling the project:
+
[.tabset]
Java::
+
[source,shell]
----
mvn compile
----

Scala::
+
[source,shell]
----
sbt compile
----


. Add the `getItemPopularity` method to the `ShoppingCartServiceImpl`:
+

For this you have to add the `ItemPopularityRepository` as a constructor parameter to the `ShoppingCartServiceImpl`. The `ItemPopularityRepository` instance is created in [.group-scala]#`Main.scala`# [.group-java]#`Main.java`# so pass that instance as parameter to `ShoppingCartServiceImpl`.

[.tabset]
Java::
+
.src/main/java/shopping/cart/ShoppingCartServiceImpl.java
[source,java,indent=0]
----
include::example$04-shopping-cart-service-java/src/main/java/shopping/cart/ShoppingCartServiceImpl.java[tag=getItemPopularity]
----
+
<1> Add the `ItemPopularityRepository` to the service implementation constructor.
<2> Use the `ActorSystem` to get an instance of an `Executor` tailored for running JDBC blocking operations.
<3> Implement `getItemPopularity` by calling the repository to find the projected model by id and wrap it with `CompletableFuture.supplyAsync`. 

Scala::
+
.src/main/scala/shopping/cart/ShoppingCartServiceImpl.scala
[source,scala,indent=0]
----
include::example$04-shopping-cart-service-scala/src/main/scala/shopping/cart/ShoppingCartServiceImpl.scala[tag=getItemPopularity]
----

[.group-java]
[IMPORTANT]
====
Calls to the repository are blocking therefore we wrap it with `CompletableFuture.supplyAsync` and we use the JDBC blocking executor to run it. This is a pre-configured dispatcher provided by Akka Projections. Its pool size can be configured with settings `akka.projection.jdbc.blocking-jdbc-dispatcher.thread-pool-executor.fixed-pool-size` (see src/main/resources/persistence.conf).

Make sure to follow that pattern whenever you interact with a DB repository. 
====

== Run locally

Try your solution by running locally:

. Start the docker containers, unless they are already running:
+
[source,shell script]
----
docker-compose up -d
----

. Create the item popularity table by creating a `ddl-scripts/create_user_tables.sql` file and adding the SQL statement below.
+
[source,sql,indent=0]
----
include::example$04-shopping-cart-service-java/ddl-scripts/create_user_tables.sql[]
----

. Load the file into Postgres:
+
[source,shell script]
----
docker exec -i shopping-cart-service_postgres-db_1 psql -U shopping-cart -t < ddl-scripts/create_user_tables.sql
----
+
include::docker-important.adoc[]

. Run the service with:
+
[.group-java]
[source,shell script]
----
# make sure to compile before running exec:exec
mvn compile exec:exec -DAPP_CONFIG=local1.conf
----
+
[.group-scala]
[source,shell script]
----
sbt -Dconfig.resource=local1.conf run
----

=== Exercise the service

Use `grpcurl` to exercise the service: 

. Add 5 hoodies to a cart:
+
[source,shell script]
----
grpcurl -d '{"cartId":"cart1", "itemId":"hoodie", "quantity":5}' -plaintext 127.0.0.1:8101 shoppingcart.ShoppingCartService.AddItem
----

. Check the popularity of the item:
+
[source,shell script]
----
grpcurl -d '{"itemId":"hoodie"}' -plaintext 127.0.0.1:8101 shoppingcart.ShoppingCartService.GetItemPopularity
----

. Add 2 hoodies to another cart:
+
[source,shell script]
----
grpcurl -d '{"cartId":"cart3", "itemId":"hoodie", "quantity":2}' -plaintext 127.0.0.1:8101 shoppingcart.ShoppingCartService.AddItem
----

. Check that the popularity count increased to 7:
+
[source,shell script]
----
grpcurl -d '{"itemId":"hoodie"}' -plaintext 127.0.0.1:8101 shoppingcart.ShoppingCartService.GetItemPopularity
----

=== Stop the service

When finished, stop the service with `ctrl-c`. Leave Postgres running for the next set of steps, or stop it with:

[source,shell script]
----
docker-compose down
----

:!Sectnums:
== Learn more

* xref:concepts:cqrs.adoc[CQRS concepts].
* {akka-projection}/[Akka Projection reference documentation {tab-icon}, window="tab"].
* {akka}/typed/cluster-sharded-daemon-process.html[Akka Sharded Daemon Process reference documentation {tab-icon}, window="tab"].
* xref:how-to:cassandra-alternative.adoc[]
