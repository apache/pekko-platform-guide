= Command Query Responsibility Segregation (CQRS)
:toc:
:toc-title: ON THIS PAGE
:toclevels: 2

include::ROOT:partial$include.adoc[]

== Concepts

CQRS documentation in the link:{akka-projection}/use-cases.html[Akka Projection documentation].

The idea of CQRS is to establish specific data representations suited to answer the queries we want to handle. These representations (or "projections", or "read-side models") are built up by listening to the stream of events that update the entities.

== Akka Projection

link:{akka-projection}/[Akka Projection] is designed to listen to a stream of events and built up data in a different representation, a projection.

The entry-point to its API is the `EventSourcedProvider` which listens to the events of an entity which are marked with a tag. The tag has to be attached to the entity when it is created.

Our shopping cart events get tagged with a tag that contains an index so we can have parallel listeners to events for different sets of shopping carts.

== TODO explain tag better, more tags

The projection defines a source provider which defines the events which should be projected to the read model. To do that it specifies the base class for the events it should provide (`ShoppingCart.Event`), that these events come from the Cassandra journal and event tag.

For this projection we choose "at-least once" semantics -- in some scenarios the same event might be seen more than once. To be able to resume the projection after failures or restarts the offset of the events are tracked and stored to
Cassandra by the link:{akka-projection}cassandra.html#at-least-once[`CassandraProjection.atLeastOnce`].

Each event will be passed to the event handler which should  update the read model of our entity (`ShoppingCartProjectionHandler`).

[source,scala]
----
include::example$shopping-cart-service-scala/src/main/scala/sample/shoppingcart/ItemPopularityProjection.scala[tag=projection]
----


link:{akka}/typed/persistence.html#tagging[Tagging in the Akka Persistence reference documentation].
